# 从最简单场景开始
React用的不算多，主要项目还是用Vue来写，不过本着刻舟求剑的原则，还是现在学习一番React的源码吧。
先从最常见的一句代码开始:
```js
import React from 'react';
class ShoppingList extends React.Component {
    render () {
        return (
            <div></div>
        )
    }
}
```
这里import进来的React对象就在项目目录packages/react/src/React.js这个路径下的js文件中，大概有如下的东西:
```js
const React = {
  ...
  Component,
  ...
};
```
我们这里目前只关心其中的这个东西: Component, 它来自packages/react/src/ReactBaseClasses.js这个文件
```js
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
Component.prototype.setState = function(partialState, callback) {};
Component.prototype.forceUpdate = function(callback) {};
```
这是一个es5方式写的构造函数，可以看到我们新建的组件都是继承自这个父元素。
他有三个参数，其中props经常使用，context和updater还不知道什么意思。
另外它原型链上的两个方法setState、forceUpdate。

现在只从最常用的setState开始看起。
```js
Component.prototype.setState = function(partialState, callback) {
  ...
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```
this.updater是个什么东西？
它是构造函数的三个参数之一，我们看到好像并没有传入这个参数，那么他的值就是ReactNoopUpdateQueue。

我们看看ReactNoopUpdateQueue是什么样子的：
```js
const ReactNoopUpdateQueue = {
  isMounted: function(publicInstance) {
    return false;
  },
  enqueueForceUpdate: function(publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },
  enqueueReplaceState: function(
    publicInstance,
    completeState,
    callback,
    callerName,
  ) {
    warnNoop(publicInstance, 'replaceState');
  },
  enqueueSetState: function(
    publicInstance,
    partialState,
    callback,
    callerName,
  ) {
    warnNoop(publicInstance, 'setState');
  },
};
```
这只是一个模板对象，名字也告诉你了Noop，但是从内部函数的命名上还是看出端倪的，大部分都是有个enqueue开头的名字。虽然不知道什么意思，但是可以判断跟队列有关(从目前搜索到资料来看，setState是个异步过程，那我猜大概思路应该是把想要做的事情放入一个队列，异步操作，这点跟Vue有点神似)。

但是如果函数不做什么事情的话，写的再好也没用，带着这样的问题，在网上搜索的一番，大概的答案是this.updater会在下面函数调用中替换为跟组件定义的render函数相关的一个updater，但是样子大概跟上面的Noop这个差不多。
```js
ReactDOM.render(element, document.getElementById('root'));
```
那么目前这条线索就断了，下面转入ReactDOM看看到底是如何生成不同的updater的吧。

# render函数
目前只关心ReactDOM对象上的render函数：
```js
const ReactDOM: Object = {
  ...
  render(
    element: React$Element<any>,
    container: DOMContainer,
    callback: ?Function,
  ) {
    ...
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  },
  ...

```
我们发现它只是把legacyRenderSubtreeIntoContainer函数封装了一层。
那么下面要好好研究下这个legacyRenderSubtreeIntoContainer函数：
```js
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,// null
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  ...
  let root: Root = (container._reactRootContainer: any);
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(() => {
      if (parentComponent != null) {
        root.legacy_renderSubtreeIntoContainer(
          parentComponent,
          children,
          callback, 
        );
        // 这个分支不会走
      } else {
        root.render(children, callback);
      }
    });
  } else {
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    if (parentComponent != null) {
      root.legacy_renderSubtreeIntoContainer(
        parentComponent,
        children,
        callback,
      );
      // 这个分支不会走
    } else {
      root.render(children, callback);
    }
  }
  return getPublicRootInstance(root._internalRoot);
}
```
这个函数其实就做了一件事：
看传入的container是否有这个_reactRootContainer属性(貌似是跟所谓fiber架构相关的东西，fiber架构据说是个复杂的东西，所有相关的先不研究)，
如果有执行一段逻辑，如果没有造出一个，并执行另一端逻辑。并且两段逻辑大部分内容是差不多的。

下面先看看如何造出这个属性：
```js
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate//false,
    );
```
看看legacyCreateRootFromDOMContainer这个函数：
```js
function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    while ((rootSibling = container.lastChild)) {
      ...
      container.removeChild(rootSibling);
    }
  }
  ...
  // Legacy roots are not async by default.
  const isConcurrent = false;
  return new ReactRoot(container, isConcurrent, shouldHydrate);
}
```
我们可以看出legacyCreateRootFromDOMContainer这个函数返回了一个ReactRoot类型的对象，而这个对象就是legacyRenderSubtreeIntoContainer函数中的root，以及container上_reactRootContainer属性的值。

```js
function ReactRoot(
  container: DOMContainer,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}
ReactRoot.prototype.render
ReactRoot.prototype.unmount
ReactRoot.prototype.legacy_renderSubtreeIntoContainer
```

其中createContainer来自packages/react-reconciler/src/ReactFiberReconciler.js这个文件,其实就是对createFiberRoot的简单封装：(好多fiber关键字，看来还是躲不开的)

```js
export function createContainer(
  containerInfo: Container,
  isConcurrent: boolean,
  hydrate: boolean,
): OpaqueRoot {
  return createFiberRoot(containerInfo, isConcurrent, hydrate);
}
```
而createFiberRoot则来自：packages/react-reconciler/src/ReactFiberRoot.js：
```js
export function createFiberRoot(
  containerInfo: any,
  isConcurrent: boolean,
  hydrate: boolean,
): FiberRoot {
  const uninitializedFiber = createHostRootFiber(isConcurrent);

  let root;
  if (enableSchedulerTracing) {
    root = ({
      current: uninitializedFiber,
      ...// 一堆属性
    }: FiberRoot);
  } else {
    root = ({
      current: uninitializedFiber,
      ...// 一堆属性
    }: BaseFiberRootProperties);
  }

  uninitializedFiber.stateNode = root;
  return ((root: any): FiberRoot);
}
```
uninitializedFiber就是一个FiberNode(其实就是有一堆属性的对象，由这些属性来控制一些过程吧，一个猜测)。
返回的root的一个属性current就是这个未初始化的Fiber(uninitializedFiber)

到此搞清楚了legacyRenderSubtreeIntoContainer中root是什么东西：
- 就是legacyCreateRootFromDOMContainer这个函数的返回结果:是个new ReactRoot的实例对象reactRoot
- reactRoot有个属性_internalRoot是一个FiberRoot
- 这个FiberRoot有个属性uninitializedFiber是个FiberNode

然后由于parentComponent为null，所以这里只会走到
root.render(children, callback)，也就是reactRoot对象的render函数：
```js
ReactRoot.prototype.render = function(
  children: ReactNodeList,
  callback: ?() => mixed,
): Work {
  const root = this._internalRoot;
  const work = new ReactWork();
  callback = callback === undefined ? null : callback;
  ...
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, null, work._onCommit);
  return work;
};
```
到了这里出现一个有意思的东西ReactWork, 从名字来看类似一个job的东西吧(一个猜测)，从这句work.then(callback)来看，~~还是个Promise~~只是个thenable的东西。
我们先看看ReactWork是什么：
```js
function ReactWork() {
  this._callbacks = null;
  this._didCommit = false;
  // TODO: Avoid need to bind by replacing callbacks in the update queue with
  // list of Work objects.
  this._onCommit = this._onCommit.bind(this);
}
ReactWork.prototype.then
ReactWork.prototype._onCommit
```
有3个内部属性，原型上有2个方法。
看看then方法：
```js
ReactWork.prototype.then = function(onCommit: () => mixed): void {
  if (this._didCommit) {
    onCommit();
    return;
  }
  let callbacks = this._callbacks;
  if (callbacks === null) {
    callbacks = this._callbacks = [];
  }
  callbacks.push(onCommit);
};
```
如果didCommit就执行onCommit，初始为false，所以只会把onCommit推入_callbacks队列。

然后应该是重头戏updateContainer了：
```js
export function updateContainer(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,//null
  callback: ?Function,
): ExpirationTime {
  const current = container.current;
  const currentTime = requestCurrentTime();
  const expirationTime = computeExpirationForFiber(currentTime, current);
  return updateContainerAtExpirationTime(
    element,
    container,
    parentComponent,
    expirationTime,
    callback,
  );
}
```
const current = container.current这个current就是前文提到的未初始化的Fiber(uninitializedFiber)，而未初始化的Fiber也是前文提到的：uninitializedFiber就是一个FiberNode(其实就是有一堆属性的对象，由这些属性来控制一些过程吧，一个猜测)。
expirationTime看起来需要深入fiber机制内部，先不管，从字面意思来看，是个失效时间(什么的失效时间？猜测需要的时候检测是否失效，失效跟不失效逻辑会有不同，并且还会更新这个时间，应该就是个timer的东东)

下面来看updateContainerAtExpirationTime：
```js
export function updateContainerAtExpirationTime(
  element: ReactNodeList,
  container: OpaqueRoot,
  parentComponent: ?React$Component<any, any>,//null
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  // TODO: If this is a nested container, this won't be the root.
  const current = container.current;
  ...
  const context = getContextForSubtree(parentComponent);
  if (container.context === null) {
    container.context = context;
  } else {
    container.pendingContext = context;
  }

  return scheduleRootUpdate(current, element, expirationTime, callback);
}
```
先来看看这个context是什么东东：
```js
function getContextForSubtree(
  parentComponent: ?React$Component<any, any>,
): Object {
  if (!parentComponent) {
    return emptyContextObject;
  }
  ...
}
```
我们这里的parentComponent为null，所以直接返回emptyContextObject：
export const emptyContextObject = {};
就是个空对象。

接下来看看scheduleRootUpdate：
```js
function scheduleRootUpdate(
  current: Fiber,
  element: ReactNodeList,
  expirationTime: ExpirationTime,
  callback: ?Function,
) {
  ...
  const update = createUpdate(expirationTime);
  // Caution: React DevTools currently depends on this property
  // being called "element".
  update.payload = {element};

  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    ...
    update.callback = callback;
  }

  flushPassiveEffects();
  enqueueUpdate(current, update);
  scheduleWork(current, expirationTime);

  return expirationTime;
}
```
先看看update是什么东西：
```js
export function createUpdate(expirationTime: ExpirationTime): Update<*> {
  return {
    expirationTime: expirationTime,

    tag: UpdateState,
    payload: null,
    callback: null,

    next: null,
    nextEffect: null,
  };
}
```
update就是个有一些属性的对象。
接下来的flushPassiveEffects没看懂，可能跟一些被动效果有关的，先不管。
接下来看enqueueUpdate:
```js
export function enqueueUpdate<State>(fiber: Fiber, update: Update<State>) {
  // Update queues are created lazily.
  const alternate = fiber.alternate;
  let queue1;
  let queue2;
  if (alternate === null) {
    // There's only one fiber.
    queue1 = fiber.updateQueue;
    queue2 = null;
    if (queue1 === null) {
      queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
    }
  } else {
    // There are two owners.
    queue1 = fiber.updateQueue;
    queue2 = alternate.updateQueue;
    if (queue1 === null) {
      if (queue2 === null) {
        // Neither fiber has an update queue. Create new ones.
        queue1 = fiber.updateQueue = createUpdateQueue(fiber.memoizedState);
        queue2 = alternate.updateQueue = createUpdateQueue(
          alternate.memoizedState,
        );
      } else {
        // Only one fiber has an update queue. Clone to create a new one.
        queue1 = fiber.updateQueue = cloneUpdateQueue(queue2);
      }
    } else {
      if (queue2 === null) {
        // Only one fiber has an update queue. Clone to create a new one.
        queue2 = alternate.updateQueue = cloneUpdateQueue(queue1);
      } else {
        // Both owners have an update queue.
      }
    }
  }
  if (queue2 === null || queue1 === queue2) {
    // There's only a single queue.
    appendUpdateToQueue(queue1, update);
  } else {
    // There are two queues. We need to append the update to both queues,
    // while accounting for the persistent structure of the list — we don't
    // want the same update to be added multiple times.
    if (queue1.lastUpdate === null || queue2.lastUpdate === null) {
      // One of the queues is not empty. We must add the update to both queues.
      appendUpdateToQueue(queue1, update);
      appendUpdateToQueue(queue2, update);
    } else {
      // Both queues are non-empty. The last update is the same in both lists,
      // because of structural sharing. So, only append to one of the lists.
      appendUpdateToQueue(queue1, update);
      // But we still need to update the `lastUpdate` pointer of queue2.
      queue2.lastUpdate = update;
    }
  }
  ...
}
```