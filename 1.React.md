# 从最简单场景开始
React用的不算多，主要项目还是用Vue来写，不过本着刻舟求剑的原则，还是现在学习一番React的源码吧。
先从最常见的一句代码开始:
```js
import React from 'react';
class ShoppingList extends React.Component {
    render () {
        return (
            <div></div>
        )
    }
}
```
这里import进来的React对象就在项目目录packages/react/src/React.js这个路径下的js文件中，大概有如下的东西:
```js
const React = {
  ...
  Component,
  ...
};
```
我们这里目前只关心其中的这个东西: Component, 它来自packages/react/src/ReactBaseClasses.js这个文件
```js
function Component(props, context, updater) {
  this.props = props;
  this.context = context;
  this.refs = emptyObject;
  this.updater = updater || ReactNoopUpdateQueue;
}

Component.prototype.isReactComponent = {};
Component.prototype.setState = function(partialState, callback) {};
Component.prototype.forceUpdate = function(callback) {};
```
这是一个es5方式写的构造函数，可以看到我们新建的组件都是继承自这个父元素。
他有三个参数，其中props经常使用，context和updater还不知道什么意思。
另外它原型链上的两个方法setState、forceUpdate。

现在只从最常用的setState开始看起。
```js
Component.prototype.setState = function(partialState, callback) {
  ...
  this.updater.enqueueSetState(this, partialState, callback, 'setState');
};
```
this.updater是个什么东西？
它是构造函数的三个参数之一，我们看到好像并没有传入这个参数，那么他的值就是ReactNoopUpdateQueue。

我们看看ReactNoopUpdateQueue是什么样子的：
```js
const ReactNoopUpdateQueue = {
  isMounted: function(publicInstance) {
    return false;
  },
  enqueueForceUpdate: function(publicInstance, callback, callerName) {
    warnNoop(publicInstance, 'forceUpdate');
  },
  enqueueReplaceState: function(
    publicInstance,
    completeState,
    callback,
    callerName,
  ) {
    warnNoop(publicInstance, 'replaceState');
  },
  enqueueSetState: function(
    publicInstance,
    partialState,
    callback,
    callerName,
  ) {
    warnNoop(publicInstance, 'setState');
  },
};
```
这只是一个模板对象，名字也告诉你了Noop，但是从内部函数的命名上还是看出端倪的，大部分都是有个enqueue开头的名字。虽然不知道什么意思，但是可以判断跟队列有关(从目前搜索到资料来看，setState是个异步过程，那我猜大概思路应该是把想要做的事情放入一个队列，异步操作，这点跟Vue有点神似)。

但是如果函数不做什么事情的话，写的再好也没用，带着这样的问题，在网上搜索的一番，大概的答案是this.updater会在下面函数调用中替换为跟组件定义的render函数相关的一个updater，但是样子大概跟上面的Noop这个差不多。
```js
ReactDOM.render(element, document.getElementById('root'));
```
那么目前这条线索就断了，下面转入ReactDOM看看到底是如何生成不同的updater的吧。

# render函数
目前只关心ReactDOM对象上的render函数：
```js
const ReactDOM: Object = {
  ...
  render(
    element: React$Element<any>,
    container: DOMContainer,
    callback: ?Function,
  ) {
    ...
    return legacyRenderSubtreeIntoContainer(
      null,
      element,
      container,
      false,
      callback,
    );
  },
  ...

```
我们发现它只是把legacyRenderSubtreeIntoContainer函数封装了一层。
那么下面要好好研究下这个legacyRenderSubtreeIntoContainer函数：
```js
function legacyRenderSubtreeIntoContainer(
  parentComponent: ?React$Component<any, any>,
  children: ReactNodeList,
  container: DOMContainer,
  forceHydrate: boolean,
  callback: ?Function,
) {
  ...
  let root: Root = (container._reactRootContainer: any);
  if (!root) {
    // Initial mount
    root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate,
    );
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Initial mount should not be batched.
    unbatchedUpdates(() => {
      if (parentComponent != null) {
        root.legacy_renderSubtreeIntoContainer(
          parentComponent,
          children,
          callback,
        );
      } else {
        root.render(children, callback);
      }
    });
  } else {
    if (typeof callback === 'function') {
      const originalCallback = callback;
      callback = function() {
        const instance = getPublicRootInstance(root._internalRoot);
        originalCallback.call(instance);
      };
    }
    // Update
    if (parentComponent != null) {
      root.legacy_renderSubtreeIntoContainer(
        parentComponent,
        children,
        callback,
      );
    } else {
      root.render(children, callback);
    }
  }
  return getPublicRootInstance(root._internalRoot);
}
```
这个函数其实就做了一件事：
看传入的container是否有这个_reactRootContainer属性(貌似是跟所谓fiber架构相关的东西，fiber架构据说是个复杂的东西，所有相关的先不研究)，
如果有执行一段逻辑，如果没有造出一个，并执行另一端逻辑。并且两段逻辑大部分内容是差不多的。

下面先看看如何造出这个属性：
```js
root = container._reactRootContainer = legacyCreateRootFromDOMContainer(
      container,
      forceHydrate//false,
    );
```
看看legacyCreateRootFromDOMContainer这个函数：
```js
function legacyCreateRootFromDOMContainer(
  container: DOMContainer,
  forceHydrate: boolean,
): Root {
  const shouldHydrate =
    forceHydrate || shouldHydrateDueToLegacyHeuristic(container);
  // First clear any existing content.
  if (!shouldHydrate) {
    let warned = false;
    let rootSibling;
    while ((rootSibling = container.lastChild)) {
      ...
      container.removeChild(rootSibling);
    }
  }
  ...
  // Legacy roots are not async by default.
  const isConcurrent = false;
  return new ReactRoot(container, isConcurrent, shouldHydrate);
}
```
我们可以看出legacyCreateRootFromDOMContainer这个函数返回了一个ReactRoot类型的对象，而这个对象就是legacyRenderSubtreeIntoContainer函数中的root，以及container上_reactRootContainer属性的值。

```js
function ReactRoot(
  container: DOMContainer,
  isConcurrent: boolean,
  hydrate: boolean,
) {
  const root = createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}
ReactRoot.prototype.render
ReactRoot.prototype.unmount
ReactRoot.prototype.legacy_renderSubtreeIntoContainer
```

其中createContainer来自packages/react-reconciler/src/ReactFiberReconciler.js这个文件：(好多fiber关键字，看来还是躲不开的)

```js
export function createContainer(
  containerInfo: Container,
  isConcurrent: boolean,
  hydrate: boolean,
): OpaqueRoot {
  return createFiberRoot(containerInfo, isConcurrent, hydrate);
}
```
而createFiberRoot则来自：packages/react-reconciler/src/ReactFiberRoot.js：
```js
export function createFiberRoot(
  containerInfo: any,
  isConcurrent: boolean,
  hydrate: boolean,
): FiberRoot {
  // Cyclic construction. This cheats the type system right now because
  // stateNode is any.
  const uninitializedFiber = createHostRootFiber(isConcurrent);

  let root;
  if (enableSchedulerTracing) {
    root = ({
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      pingCache: null,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,

      interactionThreadID: unstable_getThreadID(),
      memoizedInteractions: new Set(),
      pendingInteractionMap: new Map(),
    }: FiberRoot);
  } else {
    root = ({
      current: uninitializedFiber,
      containerInfo: containerInfo,
      pendingChildren: null,

      pingCache: null,

      earliestPendingTime: NoWork,
      latestPendingTime: NoWork,
      earliestSuspendedTime: NoWork,
      latestSuspendedTime: NoWork,
      latestPingedTime: NoWork,

      didError: false,

      pendingCommitExpirationTime: NoWork,
      finishedWork: null,
      timeoutHandle: noTimeout,
      context: null,
      pendingContext: null,
      hydrate,
      nextExpirationTimeToWorkOn: NoWork,
      expirationTime: NoWork,
      firstBatch: null,
      nextScheduledRoot: null,
    }: BaseFiberRootProperties);
  }

  uninitializedFiber.stateNode = root;

  // The reason for the way the Flow types are structured in this file,
  // Is to avoid needing :any casts everywhere interaction tracing fields are used.
  // Unfortunately that requires an :any cast for non-interaction tracing capable builds.
  // $FlowFixMe Remove this :any cast and replace it with something better.
  return ((root: any): FiberRoot);
}
```
